#pragma once

#include <cgv/gui/key_event.h>
#include <cgv/gui/throttle_event.h>
#include <cgv/gui/stick_event.h>
#include <cgv/gui/pose_event.h>
#include <vr/vr_event.h>
#include <cgv/gui/window.h>
#include <cgv/signal/signal.h>
#include <cgv/signal/bool_signal.h>

#include "lib_begin.h"

namespace cgv {
	namespace gui {

		/// vr key events use the key codes defined in vr::VRKeys
		class CGV_API vr_key_event : public cgv::gui::key_event
		{
		protected:
			/// store device handle
			void* device_handle;
			/// store controller index (0 .. left, 1.. right) of vr kit
			unsigned short controller_index;
			/// store player index
			unsigned short player_index;
			/// access to current vr state 
			const vr::vr_kit_state& state;
		public:
			/// construct a key event from its textual description 
			vr_key_event(void* _device_handle, unsigned _player_index, unsigned _controller_index, const vr::vr_kit_state& _state,
				unsigned short _key = 0, KeyAction _action = KA_PRESS, unsigned char _char = 0,
				unsigned char _modifiers = 0, double _time = 0);
			/// return the device id, by default returns 0
			void* get_device_handle() const { return device_handle; }
			/// return controller index (0 .. left, 1.. right) of vr kit
			unsigned get_controller_index() const { return controller_index; }
			/// return player index
			unsigned get_player_index() const { return player_index; }
			/// return the state
			const vr::vr_kit_state& get_state() const { return state; }
			/// write to stream
			void stream_out(std::ostream& os) const;
			/// read from stream
			void stream_in(std::istream& is);
		};

		/// vr extension of throttle event
		class CGV_API vr_throttle_event : public throttle_event
		{
		protected:
			/// store device handle
			void* device_handle;
			/// access to current vr state 
			const vr::vr_kit_state& state;
		public:
			/// construct a throttle event from value and value change
			vr_throttle_event(void* _device_handle, unsigned _controller_index, const vr::vr_kit_state& _state, 
				float _x, float _dx, unsigned _player_index = 0, unsigned _throttle_index = 0, double _time = 0);
			/// return the device id, by default returns 0
			void* get_device_handle() const { return device_handle; }
			/// return the state
			const vr::vr_kit_state& get_state() const { return state; }
			/// write to stream
			void stream_out(std::ostream& os) const;
		};

		/// vr extension of stick event
		class CGV_API vr_stick_event : public stick_event
		{
		protected:
			/// store device handle
			void* device_handle;
			/// access to current vr state 
			const vr::vr_kit_state& state;
		public:
			/// construct a key event from its textual description 
			vr_stick_event(void* _device_handle, unsigned _controller_index, const vr::vr_kit_state& _state, 
				StickAction _action, float _x, float _y, float _dx, float _dy,
				unsigned _player_index = 0, unsigned _stick_index = 0, double _time = 0);
			/// return the device id, by default returns 0
			void* get_device_handle() const { return device_handle; }
			/// return the state
			const vr::vr_kit_state& get_state() const { return state; }
			/// write to stream
			void stream_out(std::ostream& os) const;
		};

		/// vr extension of pose events
		class CGV_API vr_pose_event : public pose_event
		{
		protected:
			/// store device handle
			void* device_handle;
			/// access to current vr state 
			const vr::vr_kit_state& state;
		public:
			/// construct a key event from its textual description 
			vr_pose_event(void* _device_handle, short _trackable_index, const vr::vr_kit_state& _state,
				const float *_pose, unsigned short _player_index, double _time = 0);
			/// return the device id, by default returns 0
			void* get_device_handle() const { return device_handle; }
			/// return the state
			const vr::vr_kit_state& get_state() const { return state; }
			/// write to stream
			void stream_out(std::ostream& os) const;
		};

		/// flags to define which events should be generated by server
		enum VREventTypeFlags
		{
			VRE_NONE = 0,
			VRE_DEVICE = 1,
			VRE_STATUS = 2,
			VRE_KEY = 4,
			VRE_THROTTLE = 8, 
			VRE_STICK = 16,
			VRE_STICK_KEY = 32, // whether stick touch and press actions should be translated to key events
			VRE_POSE = 64,
			VRE_ALL = 127
		};

		/// server for vr events
		class CGV_API vr_server
		{
		protected:
			double last_device_scan;
			double device_scan_interval;
			std::vector<void*> vr_kit_handles;
			std::vector<vr::vr_kit_state> last_states;
			std::vector<unsigned> last_time_stamps;
			VREventTypeFlags event_type_flags;
			///
			void emit_events_and_update_state(void* kit_handle, const vr::vr_kit_state& new_state, int kit_index, VREventTypeFlags flags, double time);
		public:
			/// construct server with default configuration
			vr_server();
			/// query the currently set event type flags
			VREventTypeFlags get_event_type_flags() const;
			/// set the event type flags of to be emitted events
			void set_event_type_flags(VREventTypeFlags flags);
			/// set time interval in seconds to check for device connection changes
			void set_device_scan_interval(double duration);
			/// check enabled gamepad devices for new events and dispatch them through the on_event signal
			void check_device_changes(double time);
			/// check for new vr devices, query their current states and dispatch events through on_event, on_status_change and on_device_change signals
			void check_and_emit_events(double time);
			/// in case the current vr state of a kit had been queried outside, use this function to communicate the new state to the server; return whether kit_handle had been seen by server before
			bool check_new_state(void* kit_handle, const vr::vr_kit_state& new_state, double time);
			/// same as previous function but with overwrite of flags
			bool check_new_state(void* kit_handle, const vr::vr_kit_state& new_state, double time, VREventTypeFlags flags);
			/// signal emitted to dispatch events
			cgv::signal::bool_signal<cgv::gui::event&> on_event;
			/// signal emitted to notify about device changes, first argument is handle and second a flag telling whether device got connected or if false disconnected
			cgv::signal::signal<void*, bool> on_device_change;
			/// signal emitted to notify about status changes of trackables, first argument is handle, second -1 for hmd + 0|1 for left|right controller, third is old status and fourth new status
			cgv::signal::signal<void*, int, vr::VRStatus, vr::VRStatus> on_status_change;
		};

		/// return a reference to vr server singleton
		extern CGV_API vr_server& ref_vr_server();

		/// connect the vr server to the given window or the first window of the application, if window is not provided
		extern CGV_API void connect_vr_server(bool connect_device_change_only_to_animation_trigger = true, cgv::gui::window_ptr w = cgv::gui::window_ptr());
	}
}

#include <cgv/config/lib_end.h>
