<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cgv: cgv::base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00705.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cgv::base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the base namespace holds the base hierarchy, support for plugin registration and signals  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">argument_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for objects that process unknown command line arguments  <a href="a00017.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">attach_slot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">base_generator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">base_method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">command_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure to store an analized command  <a href="a00022.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">config_file_driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for a config file driver that handles permanent registration and gui config files.  <a href="a00023.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">config_file_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for observers of config files.  <a href="a00024.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">console</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that add several listeners and objects.  <a href="a00026.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for a factory that allows to create objects derived from <a class="el" href="a00019.html">cgv::base::base</a>  <a href="a00027.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">factory_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using the standard constructor  <a href="a00028.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">factory_impl_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using a constructor with one argument of type CA  <a href="a00029.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">factory_impl_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using a constructor with two arguments of types CA1 and CA2  <a href="a00030.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">factory_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type  <a href="a00031.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">factory_registration_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type that uses a constructor with one argument of type CA  <a href="a00032.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">factory_registration_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type that uses a constructor with one argument of type CA  <a href="a00033.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">find_action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple action implementation that adds nodes implementing X to a results vector  <a href="a00034.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">matched_method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">method_action_2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">named</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">object_constructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract base class of helpers to perform delayed registration and creation of objects in case that the registration is currently disabled  <a href="a00041.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">object_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type  <a href="a00042.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">object_registration_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type with one constructor argument  <a href="a00043.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">object_registration_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type with two constructor arguments  <a href="a00044.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">registration_listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that allows to listen to registration events.  <a href="a00045.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">registration_order_definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class whose constructor calls the <code><a class="el" href="a00705.html#ada908977e738c6da6230a698912bebc4" title="specify a partial order of objects for registration ">define_registration_order()</a></code> function  <a href="a00046.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">resource_file_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">information registered with each resource file  <a href="a00047.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">resource_file_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a resource file  <a href="a00048.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">resource_string_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a resource string  <a href="a00049.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">server</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that add provides very basic functionality.  <a href="a00050.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">single_method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">single_method_action_2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">test</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure used to register a test function  <a href="a00053.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">test_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">declare an instance of <a class="el" href="a00054.html" title="declare an instance of test_registration as static variable in order to register a test function in a...">test_registration</a> as static variable in order to register a test function in a test plugin  <a href="a00054.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">traverse_callback_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface of a handler for traverse callbacks  <a href="a00055.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">traverse_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">nodes should inherit from this policy class to allow selective tree traversals  <a href="a00056.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">traverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class used to traverse a tree structure  <a href="a00057.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adf49b672c57e35e9ac4a9d6980f50562"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf49b672c57e35e9ac4a9d6980f50562"></a>
typedef <a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00019.html">base</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a></td></tr>
<tr class="memdesc:adf49b672c57e35e9ac4a9d6980f50562"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to base <br /></td></tr>
<tr class="separator:adf49b672c57e35e9ac4a9d6980f50562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a483e13cc8a05eab04f07848e4e2ab4c8"></a>
typedef <a class="el" href="a00075.html">cgv::data::ref_ptr</a><br class="typebreak" />
&lt; <a class="el" href="a00025.html">console</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a483e13cc8a05eab04f07848e4e2ab4c8">console_ptr</a></td></tr>
<tr class="memdesc:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to console <br /></td></tr>
<tr class="separator:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea49074b205caba6f6a72feb0ad8879b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea49074b205caba6f6a72feb0ad8879b"></a>
typedef <a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00035.html">group</a>, <br class="typebreak" />
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aea49074b205caba6f6a72feb0ad8879b">group_ptr</a></td></tr>
<tr class="memdesc:aea49074b205caba6f6a72feb0ad8879b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:aea49074b205caba6f6a72feb0ad8879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ed99892cc76b1f339b9a0693bb0e1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41ed99892cc76b1f339b9a0693bb0e1f"></a>
typedef <a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00039.html">named</a>, <br class="typebreak" />
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a41ed99892cc76b1f339b9a0693bb0e1f">named_ptr</a></td></tr>
<tr class="memdesc:a41ed99892cc76b1f339b9a0693bb0e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:a41ed99892cc76b1f339b9a0693bb0e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525d4a6a81e7899a679e179ccbbab7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af525d4a6a81e7899a679e179ccbbab7b"></a>
typedef <a class="el" href="a00075.html">data::ref_ptr</a>&lt; <a class="el" href="a00040.html">node</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#af525d4a6a81e7899a679e179ccbbab7b">node_ptr</a></td></tr>
<tr class="memdesc:af525d4a6a81e7899a679e179ccbbab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:af525d4a6a81e7899a679e179ccbbab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a836526596df30a9ba628d7fd61aa2c76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a836526596df30a9ba628d7fd61aa2c76"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a> </td></tr>
<tr class="memdesc:a836526596df30a9ba628d7fd61aa2c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumerate type for all command types supported in configuration files <br /></td></tr>
<tr class="separator:a836526596df30a9ba628d7fd61aa2c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746925f26d076c26742b2dc558cbae36"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a746925f26d076c26742b2dc558cbae36">TraversePolicy</a> { , <br />
&#160;&#160;<a class="el" href="a00705.html#a746925f26d076c26742b2dc558cbae36a4dd87fc30d8a2e369fe315eb9ccde557">TP_ONLY_FOCUS</a>, 
<a class="el" href="a00705.html#a746925f26d076c26742b2dc558cbae36a69ee76315433dc44f8bfa441afefa249">TP_FIRST_FOCUS</a>, 
<a class="el" href="a00705.html#a746925f26d076c26742b2dc558cbae36a169ba2fab3a13ea551eb8d8800e459bb">TP_AUTO_FOCUS</a>, 
<a class="el" href="a00705.html#a746925f26d076c26742b2dc558cbae36a7b2b5c718b50e4241491dcb951599a8b">TP_STOP_ON_SUCCESS</a> = 8, 
<br />
&#160;&#160;<a class="el" href="a00705.html#a746925f26d076c26742b2dc558cbae36a33806b12ea827401e0a110036ddbeabe">TP_STOP_ON_FAILURE</a> = 16
<br />
 }</td></tr>
<tr class="memdesc:a746925f26d076c26742b2dc558cbae36"><td class="mdescLeft">&#160;</td><td class="mdescRight">different traversal policies  <a href="a00705.html#a746925f26d076c26742b2dc558cbae36">More...</a><br /></td></tr>
<tr class="separator:a746925f26d076c26742b2dc558cbae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e996b7f5a3a74779d9cee38497ba673"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e996b7f5a3a74779d9cee38497ba673"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a2e996b7f5a3a74779d9cee38497ba673">TraverseStrategy</a> </td></tr>
<tr class="memdesc:a2e996b7f5a3a74779d9cee38497ba673"><td class="mdescLeft">&#160;</td><td class="mdescRight">not yet implemented <br /></td></tr>
<tr class="separator:a2e996b7f5a3a74779d9cee38497ba673"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33c3982af255622d93a69be50f3b2e06"><td class="memTemplParams" colspan="2"><a class="anchor" id="a33c3982af255622d93a69be50f3b2e06"></a>
template&lt;typename T1 , class X , typename R &gt; </td></tr>
<tr class="memitem:a33c3982af255622d93a69be50f3b2e06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00051.html">single_method_action</a>&lt; X, R, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a33c3982af255622d93a69be50f3b2e06">make_action</a> (T1 _v1, R(X::*_on_begin)(T1), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a33c3982af255622d93a69be50f3b2e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and one method that is called when a node is entered <br /></td></tr>
<tr class="separator:a33c3982af255622d93a69be50f3b2e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c60002b6fe7ac3ea746b589f43d75af"></a>
template&lt;typename T1 , class X , typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00036.html">matched_method_action</a>&lt; X, R1, <br class="typebreak" />
R2, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a4c60002b6fe7ac3ea746b589f43d75af">make_action</a> (T1 _v1, R1(X::*_on_begin)(T1), R2(X::*_on_end)(T1), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a4c60002b6fe7ac3ea746b589f43d75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and two methods that are called when a node is entered and when it is left again <br /></td></tr>
<tr class="separator:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9586bffe7837806145302b7f933ea8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d9586bffe7837806145302b7f933ea8"></a>
template&lt;typename T1 , typename T2 , class X , typename R &gt; </td></tr>
<tr class="memitem:a4d9586bffe7837806145302b7f933ea8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00052.html">single_method_action_2</a>&lt; X, R, <br class="typebreak" />
T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a4d9586bffe7837806145302b7f933ea8">make_action_2</a> (T1 _v1, T2 _v2, R(X::*_on_begin)(T1, T2), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a4d9586bffe7837806145302b7f933ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and one method that is called when a node is entered <br /></td></tr>
<tr class="separator:a4d9586bffe7837806145302b7f933ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ac56137cd8bf24c23f7f6ef15a417bbdd">attach</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> slot_object, <a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> attachment_object, void *user_data)</td></tr>
<tr class="memdesc:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to attach an object to an object of type <a class="el" href="a00018.html">attach_slot</a>.  <a href="#ac56137cd8bf24c23f7f6ef15a417bbdd">More...</a><br /></td></tr>
<tr class="separator:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f23268db7fec467dfd98ab36094f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a1e3f23268db7fec467dfd98ab36094f5">get_attachment</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> slot_object)</td></tr>
<tr class="memdesc:a1e3f23268db7fec467dfd98ab36094f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">query the attachment of an <a class="el" href="a00018.html">attach_slot</a> object.  <a href="#a1e3f23268db7fec467dfd98ab36094f5">More...</a><br /></td></tr>
<tr class="separator:a1e3f23268db7fec467dfd98ab36094f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec69e775624f1ca64e001ff8b1254344"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aec69e775624f1ca64e001ff8b1254344">get_attachment_data</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> slot_object)</td></tr>
<tr class="memdesc:aec69e775624f1ca64e001ff8b1254344"><td class="mdescLeft">&#160;</td><td class="mdescRight">query the user data of the attachment of an <a class="el" href="a00018.html">attach_slot</a> object.  <a href="#aec69e775624f1ca64e001ff8b1254344">More...</a><br /></td></tr>
<tr class="separator:aec69e775624f1ca64e001ff8b1254344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63edc5ab309dd943500adb7801deeb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac63edc5ab309dd943500adb7801deeb2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#ac63edc5ab309dd943500adb7801deeb2">has_property</a> (const std::string &amp;options, const std::string &amp;property, T &amp;value, bool report_error=true)</td></tr>
<tr class="memdesc:ac63edc5ab309dd943500adb7801deeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple parsing support to access values of properties in a string of property assignment  <a href="#ac63edc5ab309dd943500adb7801deeb2">More...</a><br /></td></tr>
<tr class="separator:ac63edc5ab309dd943500adb7801deeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be27fd11c0d292bd892e3617e5a9bb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1be27fd11c0d292bd892e3617e5a9bb1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a1be27fd11c0d292bd892e3617e5a9bb1">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method)</td></tr>
<tr class="memdesc:a1be27fd11c0d292bd892e3617e5a9bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method without parameters <br /></td></tr>
<tr class="separator:a1be27fd11c0d292bd892e3617e5a9bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202cf5a404e00162a6cd9bf1fce20b40"><td class="memTemplParams" colspan="2"><a class="anchor" id="a202cf5a404e00162a6cd9bf1fce20b40"></a>
template&lt;typename R &gt; </td></tr>
<tr class="memitem:a202cf5a404e00162a6cd9bf1fce20b40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a202cf5a404e00162a6cd9bf1fce20b40">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, R &amp;r)</td></tr>
<tr class="memdesc:a202cf5a404e00162a6cd9bf1fce20b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a202cf5a404e00162a6cd9bf1fce20b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e126999223fd9f86b1f31c6fa376d33"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e126999223fd9f86b1f31c6fa376d33"></a>
template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a9e126999223fd9f86b1f31c6fa376d33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a9e126999223fd9f86b1f31c6fa376d33">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1)</td></tr>
<tr class="memdesc:a9e126999223fd9f86b1f31c6fa376d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a9e126999223fd9f86b1f31c6fa376d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fa8261e2c53a3e04be6585be30fd90"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44fa8261e2c53a3e04be6585be30fd90"></a>
template&lt;typename R , typename T1 &gt; </td></tr>
<tr class="memitem:a44fa8261e2c53a3e04be6585be30fd90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a44fa8261e2c53a3e04be6585be30fd90">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, R &amp;r)</td></tr>
<tr class="memdesc:a44fa8261e2c53a3e04be6585be30fd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a44fa8261e2c53a3e04be6585be30fd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f953d61585fc06e5a83d9f2930f9718"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f953d61585fc06e5a83d9f2930f9718"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3f953d61585fc06e5a83d9f2930f9718"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a3f953d61585fc06e5a83d9f2930f9718">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:a3f953d61585fc06e5a83d9f2930f9718"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a3f953d61585fc06e5a83d9f2930f9718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a4291e116c5aeed25efdda0889e57c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9a4291e116c5aeed25efdda0889e57c"></a>
template&lt;typename R , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae9a4291e116c5aeed25efdda0889e57c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#ae9a4291e116c5aeed25efdda0889e57c">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, R &amp;r)</td></tr>
<tr class="memdesc:ae9a4291e116c5aeed25efdda0889e57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:ae9a4291e116c5aeed25efdda0889e57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7df20fa8c04786c214a6c1f702839e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7df20fa8c04786c214a6c1f702839e6"></a>
template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ae7df20fa8c04786c214a6c1f702839e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#ae7df20fa8c04786c214a6c1f702839e6">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3)</td></tr>
<tr class="memdesc:ae7df20fa8c04786c214a6c1f702839e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:ae7df20fa8c04786c214a6c1f702839e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a07415d790552f084230bfce1537261"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a07415d790552f084230bfce1537261"></a>
template&lt;typename R , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a3a07415d790552f084230bfce1537261"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a3a07415d790552f084230bfce1537261">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, R &amp;r)</td></tr>
<tr class="memdesc:a3a07415d790552f084230bfce1537261"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a3a07415d790552f084230bfce1537261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8e4c5d0f60c036cf9009a846b41f2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d8e4c5d0f60c036cf9009a846b41f2c"></a>
template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:a6d8e4c5d0f60c036cf9009a846b41f2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a6d8e4c5d0f60c036cf9009a846b41f2c">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4)</td></tr>
<tr class="memdesc:a6d8e4c5d0f60c036cf9009a846b41f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a6d8e4c5d0f60c036cf9009a846b41f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34bf86187d22db0b2104abdf1eadd9e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad34bf86187d22db0b2104abdf1eadd9e"></a>
template&lt;typename R , typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:ad34bf86187d22db0b2104abdf1eadd9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#ad34bf86187d22db0b2104abdf1eadd9e">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, R &amp;r)</td></tr>
<tr class="memdesc:ad34bf86187d22db0b2104abdf1eadd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:ad34bf86187d22db0b2104abdf1eadd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8cd0b277bbc81beb2bfd5b69e04bd0"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa8cd0b277bbc81beb2bfd5b69e04bd0"></a>
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </td></tr>
<tr class="memitem:aaa8cd0b277bbc81beb2bfd5b69e04bd0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#aaa8cd0b277bbc81beb2bfd5b69e04bd0">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5)</td></tr>
<tr class="memdesc:aaa8cd0b277bbc81beb2bfd5b69e04bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:aaa8cd0b277bbc81beb2bfd5b69e04bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0db1bf9cb94eaeabc9f425a093da78"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb0db1bf9cb94eaeabc9f425a093da78"></a>
template&lt;typename R , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </td></tr>
<tr class="memitem:abb0db1bf9cb94eaeabc9f425a093da78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#abb0db1bf9cb94eaeabc9f425a093da78">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5, R &amp;r)</td></tr>
<tr class="memdesc:abb0db1bf9cb94eaeabc9f425a093da78"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:abb0db1bf9cb94eaeabc9f425a093da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018a4f1a56e64d55b90cccf1d1bfcfff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a018a4f1a56e64d55b90cccf1d1bfcfff"></a>
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 &gt; </td></tr>
<tr class="memitem:a018a4f1a56e64d55b90cccf1d1bfcfff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a018a4f1a56e64d55b90cccf1d1bfcfff">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5, const T6 &amp;v6)</td></tr>
<tr class="memdesc:a018a4f1a56e64d55b90cccf1d1bfcfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a018a4f1a56e64d55b90cccf1d1bfcfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab962ffaaa3abee4c8c84bce0f5e710de"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab962ffaaa3abee4c8c84bce0f5e710de"></a>
template&lt;typename R , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 &gt; </td></tr>
<tr class="memitem:ab962ffaaa3abee4c8c84bce0f5e710de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#ab962ffaaa3abee4c8c84bce0f5e710de">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5, const T6 &amp;v6, R &amp;r)</td></tr>
<tr class="memdesc:ab962ffaaa3abee4c8c84bce0f5e710de"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:ab962ffaaa3abee4c8c84bce0f5e710de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f55e8f5d544a1e04481fc01e183d6d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25f55e8f5d544a1e04481fc01e183d6d"></a>
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 &gt; </td></tr>
<tr class="memitem:a25f55e8f5d544a1e04481fc01e183d6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a25f55e8f5d544a1e04481fc01e183d6d">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5, const T6 &amp;v6, const T7 &amp;v7)</td></tr>
<tr class="memdesc:a25f55e8f5d544a1e04481fc01e183d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a25f55e8f5d544a1e04481fc01e183d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474efa189360681fcc7ff27a3a8ffe5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a474efa189360681fcc7ff27a3a8ffe5d"></a>
template&lt;typename R , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 &gt; </td></tr>
<tr class="memitem:a474efa189360681fcc7ff27a3a8ffe5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a474efa189360681fcc7ff27a3a8ffe5d">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5, const T6 &amp;v6, const T7 &amp;v7, R &amp;r)</td></tr>
<tr class="memdesc:a474efa189360681fcc7ff27a3a8ffe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a474efa189360681fcc7ff27a3a8ffe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8007d2f9b56afe37fc7528e3bbe6fcb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8007d2f9b56afe37fc7528e3bbe6fcb7"></a>
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 &gt; </td></tr>
<tr class="memitem:a8007d2f9b56afe37fc7528e3bbe6fcb7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a8007d2f9b56afe37fc7528e3bbe6fcb7">exec</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5, const T6 &amp;v6, const T7 &amp;v7, const T8 &amp;v8)</td></tr>
<tr class="memdesc:a8007d2f9b56afe37fc7528e3bbe6fcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a8007d2f9b56afe37fc7528e3bbe6fcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d33669709d7e3f9d01774e5024ecdb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a69d33669709d7e3f9d01774e5024ecdb"></a>
template&lt;typename R , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 &gt; </td></tr>
<tr class="memitem:a69d33669709d7e3f9d01774e5024ecdb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a69d33669709d7e3f9d01774e5024ecdb">eval</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> bp, const std::string &amp;method, const T1 &amp;v1, const T2 &amp;v2, const T3 &amp;v3, const T4 &amp;v4, const T5 &amp;v5, const T6 &amp;v6, const T7 &amp;v7, const T8 &amp;v8, R &amp;r)</td></tr>
<tr class="memdesc:a69d33669709d7e3f9d01774e5024ecdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">call a void method with one parameter of type T <br /></td></tr>
<tr class="separator:a69d33669709d7e3f9d01774e5024ecdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9306cf99f175197cf29de2b547b5cfb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9306cf99f175197cf29de2b547b5cfb9"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a9306cf99f175197cf29de2b547b5cfb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a9306cf99f175197cf29de2b547b5cfb9">find_interface</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> start, std::vector&lt; X * &gt; &amp;result)</td></tr>
<tr class="memdesc:a9306cf99f175197cf29de2b547b5cfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect all nodes that implement interface X <br /></td></tr>
<tr class="separator:a9306cf99f175197cf29de2b547b5cfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c767fdeab1d282ea353800d967ca44"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a87c767fdeab1d282ea353800d967ca44">find_data_file</a> (const std::string &amp;file_name, const std::string &amp;strategy, const std::string &amp;sub_directory, const std::string &amp;master_path)</td></tr>
<tr class="separator:a87c767fdeab1d282ea353800d967ca44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e30b157762c186c5c0d60359e36b5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6e30b157762c186c5c0d60359e36b5c"></a>
std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ab6e30b157762c186c5c0d60359e36b5c">ref_data_path_list</a> ()</td></tr>
<tr class="memdesc:ab6e30b157762c186c5c0d60359e36b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the data path list, which is constructed from the environment variable CGV_DATA <br /></td></tr>
<tr class="separator:ab6e30b157762c186c5c0d60359e36b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c98c559c9c197551a146a91a704e4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90c98c559c9c197551a146a91a704e4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a90c98c559c9c197551a146a91a704e4b">push_file_parent</a> (const std::string &amp;path_or_file_name)</td></tr>
<tr class="memdesc:a90c98c559c9c197551a146a91a704e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract a valid path from the given argument and push it onto the stack of parent paths. This should always be paired with a call to <a class="el" href="a00705.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack. ">pop_file_parent()</a>. <br /></td></tr>
<tr class="separator:a90c98c559c9c197551a146a91a704e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8117654ca2eb262f18fc1093c0fdf828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8117654ca2eb262f18fc1093c0fdf828"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a8117654ca2eb262f18fc1093c0fdf828">pop_file_parent</a> ()</td></tr>
<tr class="memdesc:a8117654ca2eb262f18fc1093c0fdf828"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop the latestly pushed parent path from the parent path stack. <br /></td></tr>
<tr class="separator:a8117654ca2eb262f18fc1093c0fdf828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f550111b3915df062b0bbda4795f37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aa3f550111b3915df062b0bbda4795f37">ref_parent_file_stack</a> ()</td></tr>
<tr class="memdesc:aa3f550111b3915df062b0bbda4795f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the data path list, which is constructed from the environment variable CGV_DATA  <a href="#aa3f550111b3915df062b0bbda4795f37">More...</a><br /></td></tr>
<tr class="separator:aa3f550111b3915df062b0bbda4795f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8197d89c413eb148311cd082a5f48b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8197d89c413eb148311cd082a5f48b5"></a>
FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ab8197d89c413eb148311cd082a5f48b5">open_data_file</a> (const std::string &amp;file_name, const char *mode)</td></tr>
<tr class="memdesc:ab8197d89c413eb148311cd082a5f48b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">open a file with fopen supporting resource files, that have the prefix "res://" <br /></td></tr>
<tr class="separator:ab8197d89c413eb148311cd082a5f48b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26c5e2027679d73a019e1445ca376b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab26c5e2027679d73a019e1445ca376b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ab26c5e2027679d73a019e1445ca376b0">read_data_file</a> (const std::string &amp;file_name, std::string &amp;content, bool ascii)</td></tr>
<tr class="memdesc:ab26c5e2027679d73a019e1445ca376b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">read ascii file into a string <br /></td></tr>
<tr class="separator:ab26c5e2027679d73a019e1445ca376b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb2083031cea3f3279d75aaac2b2419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeb2083031cea3f3279d75aaac2b2419"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aeeb2083031cea3f3279d75aaac2b2419">data_file_size</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:aeeb2083031cea3f3279d75aaac2b2419"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the file size of a given file with support for resource files, that have the prefix "res://" <br /></td></tr>
<tr class="separator:aeeb2083031cea3f3279d75aaac2b2419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710077a65b53cacae54e2cddbccfb5eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a710077a65b53cacae54e2cddbccfb5eb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a710077a65b53cacae54e2cddbccfb5eb">find_file_offset</a> (const std::string &amp;file_name, const char *data, unsigned int data_size)</td></tr>
<tr class="memdesc:a710077a65b53cacae54e2cddbccfb5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the offset of the given data block in the given file <br /></td></tr>
<tr class="separator:a710077a65b53cacae54e2cddbccfb5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e53bf7a9d7dbd6173cf988e3b2b6b92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a0e53bf7a9d7dbd6173cf988e3b2b6b92">register_object_internal</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> object, const std::string &amp;options)</td></tr>
<tr class="memdesc:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an object and send event to all current registration ref_listeners() <br /></td></tr>
<tr class="separator:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c6f4c42602d5fdda61e603f5cbe25e"></a>
<a class="el" href="a00705.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a78c6f4c42602d5fdda61e603f5cbe25e">analyze_command</a> (const <a class="el" href="a00322.html">cgv::utils::token</a> &amp;cmd, bool eliminate_quotes=true, <a class="el" href="a00022.html">command_info</a> *info_ptr=0)</td></tr>
<tr class="memdesc:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a command and optionally store result in the command info, returns the command type <br /></td></tr>
<tr class="separator:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db812e195f6d3578be37667b1370ff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3db812e195f6d3578be37667b1370ff5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a3db812e195f6d3578be37667b1370ff5">process_command</a> (const <a class="el" href="a00022.html">command_info</a> &amp;info)</td></tr>
<tr class="memdesc:a3db812e195f6d3578be37667b1370ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">process a command given by a command info structure, return whether command was processed correctly <br /></td></tr>
<tr class="separator:a3db812e195f6d3578be37667b1370ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab998d2f55de7a741cb22aba508cfe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1cab998d2f55de7a741cb22aba508cfe"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a1cab998d2f55de7a741cb22aba508cfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00705.html#a1cab998d2f55de7a741cb22aba508cfe">grab_focus</a> (X *instance)</td></tr>
<tr class="memdesc:a1cab998d2f55de7a741cb22aba508cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to grab the focus in the path of this node to the root of the tree <br /></td></tr>
<tr class="separator:a1cab998d2f55de7a741cb22aba508cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">processing of command line arguments</div></td></tr>
<tr class="memitem:ad93720e2cf9340ea50de0b91267680d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93720e2cf9340ea50de0b91267680d4"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ad93720e2cf9340ea50de0b91267680d4">ref_prog_name</a> ()</td></tr>
<tr class="memdesc:ad93720e2cf9340ea50de0b91267680d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a refence to the name of the started executable <br /></td></tr>
<tr class="separator:ad93720e2cf9340ea50de0b91267680d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3f2914d2fbd3613a83eaeaf8744513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a3f2914d2fbd3613a83eaeaf8744513"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a4a3f2914d2fbd3613a83eaeaf8744513">ref_prog_path_prefix</a> ()</td></tr>
<tr class="memdesc:a4a3f2914d2fbd3613a83eaeaf8744513"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a refence to the path prefix of the started executable, this can be prepended for example to dll names <br /></td></tr>
<tr class="separator:a4a3f2914d2fbd3613a83eaeaf8744513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4204680cce6ce77447fcab18a7fab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a9e4204680cce6ce77447fcab18a7fab0">register_prog_name</a> (const char *prog_name)</td></tr>
<tr class="memdesc:a9e4204680cce6ce77447fcab18a7fab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the file name of the current program.  <a href="#a9e4204680cce6ce77447fcab18a7fab0">More...</a><br /></td></tr>
<tr class="separator:a9e4204680cce6ce77447fcab18a7fab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9656474bcbb2a4b09c8e557a1e5621c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9656474bcbb2a4b09c8e557a1e5621c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ab9656474bcbb2a4b09c8e557a1e5621c">process_command_line_args</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ab9656474bcbb2a4b09c8e557a1e5621c"><td class="mdescLeft">&#160;</td><td class="mdescRight">process the command line arguments: extract program name and load all plugins <br /></td></tr>
<tr class="separator:ab9656474bcbb2a4b09c8e557a1e5621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">loading of plugins</div></td></tr>
<tr class="memitem:a59a17104b8a82638de4aab8ccfb72db2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a17104b8a82638de4aab8ccfb72db2"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a59a17104b8a82638de4aab8ccfb72db2">ref_plugin_name</a> ()</td></tr>
<tr class="memdesc:a59a17104b8a82638de4aab8ccfb72db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the currently loaded plugin <br /></td></tr>
<tr class="separator:a59a17104b8a82638de4aab8ccfb72db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf58539e451af7248fa0d2e64bbb48f5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#acf58539e451af7248fa0d2e64bbb48f5">load_plugin</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:acf58539e451af7248fa0d2e64bbb48f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a plugin or dll and return a handle to the plugin, or 0 if loading was not successful.  <a href="#acf58539e451af7248fa0d2e64bbb48f5">More...</a><br /></td></tr>
<tr class="separator:acf58539e451af7248fa0d2e64bbb48f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e8d418aa5f0c3f548c99cd63d35170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e8d418aa5f0c3f548c99cd63d35170"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#af6e8d418aa5f0c3f548c99cd63d35170">unload_plugin</a> (void *handle)</td></tr>
<tr class="memdesc:af6e8d418aa5f0c3f548c99cd63d35170"><td class="mdescLeft">&#160;</td><td class="mdescRight">unload the plugin with the given handle <br /></td></tr>
<tr class="separator:af6e8d418aa5f0c3f548c99cd63d35170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">resource file registration</div></td></tr>
<tr class="memitem:aba72200bc48e79f8a676410773a8345c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba72200bc48e79f8a676410773a8345c"></a>
std::map&lt; std::string, <br class="typebreak" />
<a class="el" href="a00047.html">resource_file_info</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aba72200bc48e79f8a676410773a8345c">ref_resource_file_map</a> ()</td></tr>
<tr class="memdesc:aba72200bc48e79f8a676410773a8345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to a mapping of resource file names to resource file infos <br /></td></tr>
<tr class="separator:aba72200bc48e79f8a676410773a8345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af8d5888d85f940a5190c1f0ff9436b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8af8d5888d85f940a5190c1f0ff9436b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a8af8d5888d85f940a5190c1f0ff9436b">register_resource_file</a> (const std::string &amp;file_path, unsigned int file_offset, unsigned int file_length, const char *file_data, const std::string &amp;source_file=&quot;&quot;)</td></tr>
<tr class="memdesc:a8af8d5888d85f940a5190c1f0ff9436b"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a resource file <br /></td></tr>
<tr class="separator:a8af8d5888d85f940a5190c1f0ff9436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a2af3c072c02cfb161f8255dd6a94c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ad2a2af3c072c02cfb161f8255dd6a94c">register_resource_string</a> (const std::string &amp;string_name, const char *string_data)</td></tr>
<tr class="memdesc:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a resource string <br /></td></tr>
<tr class="separator:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">control over the registration process</div></td></tr>
<tr class="memitem:ada908977e738c6da6230a698912bebc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ada908977e738c6da6230a698912bebc4">define_registration_order</a> (const std::string &amp;partial_order, bool before_contructor_execution=false, const std::string &amp;when=&quot;always&quot;)</td></tr>
<tr class="memdesc:ada908977e738c6da6230a698912bebc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify a partial order of objects for registration  <a href="#ada908977e738c6da6230a698912bebc4">More...</a><br /></td></tr>
<tr class="separator:ada908977e738c6da6230a698912bebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b449c961c99bd6ace1d2cb09f876558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b449c961c99bd6ace1d2cb09f876558"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a6b449c961c99bd6ace1d2cb09f876558">enable_registration_debugging</a> ()</td></tr>
<tr class="memdesc:a6b449c961c99bd6ace1d2cb09f876558"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable registration debugging <br /></td></tr>
<tr class="separator:a6b449c961c99bd6ace1d2cb09f876558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd883d8e83fdda7701bbb4df7c4a02f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafd883d8e83fdda7701bbb4df7c4a02f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aafd883d8e83fdda7701bbb4df7c4a02f">disable_registration_debugging</a> ()</td></tr>
<tr class="memdesc:aafd883d8e83fdda7701bbb4df7c4a02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable registration debugging <br /></td></tr>
<tr class="separator:aafd883d8e83fdda7701bbb4df7c4a02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf5331cfb8ec9a13997240fbbc1a3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95cf5331cfb8ec9a13997240fbbc1a3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a95cf5331cfb8ec9a13997240fbbc1a3a">is_registration_debugging_enabled</a> ()</td></tr>
<tr class="memdesc:a95cf5331cfb8ec9a13997240fbbc1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether registration debugging is enabled <br /></td></tr>
<tr class="separator:a95cf5331cfb8ec9a13997240fbbc1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa839bf46a9e8abb32cfea4964ec91507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aa839bf46a9e8abb32cfea4964ec91507">enable_registration</a> ()</td></tr>
<tr class="memdesc:aa839bf46a9e8abb32cfea4964ec91507"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable registration and send all registration events that where emitted during disabled registration  <a href="#aa839bf46a9e8abb32cfea4964ec91507">More...</a><br /></td></tr>
<tr class="separator:aa839bf46a9e8abb32cfea4964ec91507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14a0db38dca07762d43ca30f801ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b14a0db38dca07762d43ca30f801ac8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a5b14a0db38dca07762d43ca30f801ac8">disable_registration</a> ()</td></tr>
<tr class="memdesc:a5b14a0db38dca07762d43ca30f801ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">if registration is disable, all registration events are stored and sent at the momement when registration is enabled again. This feature is used when loading dlls <br /></td></tr>
<tr class="separator:a5b14a0db38dca07762d43ca30f801ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d35f03b0d843ceb855119ab9beb635"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89d35f03b0d843ceb855119ab9beb635"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a89d35f03b0d843ceb855119ab9beb635">is_registration_enabled</a> ()</td></tr>
<tr class="memdesc:a89d35f03b0d843ceb855119ab9beb635"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether registration is enabled <br /></td></tr>
<tr class="separator:a89d35f03b0d843ceb855119ab9beb635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae3b2736b2b16c7a929f0326d894be1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae3b2736b2b16c7a929f0326d894be1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a4ae3b2736b2b16c7a929f0326d894be1">enable_permanent_registration</a> ()</td></tr>
<tr class="memdesc:a4ae3b2736b2b16c7a929f0326d894be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a registration listener that stores pointers to all registered objects <br /></td></tr>
<tr class="separator:a4ae3b2736b2b16c7a929f0326d894be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1394cdecb082f474bd1d84bc3f4455"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a1394cdecb082f474bd1d84bc3f4455"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a3a1394cdecb082f474bd1d84bc3f4455">unregister_all_objects</a> ()</td></tr>
<tr class="memdesc:a3a1394cdecb082f474bd1d84bc3f4455"><td class="mdescLeft">&#160;</td><td class="mdescRight">unregister all existing objects to clean up <br /></td></tr>
<tr class="separator:a3a1394cdecb082f474bd1d84bc3f4455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1214b0c26c2b31e207cc386e7c1aa856"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1214b0c26c2b31e207cc386e7c1aa856"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a1214b0c26c2b31e207cc386e7c1aa856">get_nr_permanently_registered_objects</a> ()</td></tr>
<tr class="memdesc:a1214b0c26c2b31e207cc386e7c1aa856"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to number of permanently registered objects <br /></td></tr>
<tr class="separator:a1214b0c26c2b31e207cc386e7c1aa856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceca4778b81eaa3a7d0c0e0e8c10c8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ceca4778b81eaa3a7d0c0e0e8c10c8f"></a>
<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a5ceca4778b81eaa3a7d0c0e0e8c10c8f">get_permanently_registered_object</a> (unsigned i)</td></tr>
<tr class="memdesc:a5ceca4778b81eaa3a7d0c0e0e8c10c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to i-th permanently registered object <br /></td></tr>
<tr class="separator:a5ceca4778b81eaa3a7d0c0e0e8c10c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2a931ed984065eaf2bd3ec95624147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e2a931ed984065eaf2bd3ec95624147"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a8e2a931ed984065eaf2bd3ec95624147">disable_permanent_registration</a> ()</td></tr>
<tr class="memdesc:a8e2a931ed984065eaf2bd3ec95624147"><td class="mdescLeft">&#160;</td><td class="mdescRight">deregister registration listener and dereference pointers to registered objects <br /></td></tr>
<tr class="separator:a8e2a931ed984065eaf2bd3ec95624147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7e83d1235ad1cef1b948d2e23c7b0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee7e83d1235ad1cef1b948d2e23c7b0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aee7e83d1235ad1cef1b948d2e23c7b0e">is_permanent_registration_enabled</a> ()</td></tr>
<tr class="memdesc:aee7e83d1235ad1cef1b948d2e23c7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether permanent registration is enabled <br /></td></tr>
<tr class="separator:aee7e83d1235ad1cef1b948d2e23c7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5972c6c1a1833e46393f9361ea2b860a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a5972c6c1a1833e46393f9361ea2b860a">enable_registration_event_cleanup</a> ()</td></tr>
<tr class="memdesc:a5972c6c1a1833e46393f9361ea2b860a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable cleanup of registration events (default).  <a href="#a5972c6c1a1833e46393f9361ea2b860a">More...</a><br /></td></tr>
<tr class="separator:a5972c6c1a1833e46393f9361ea2b860a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed67b035bb486ec604fdc4f8362c747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed67b035bb486ec604fdc4f8362c747"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aeed67b035bb486ec604fdc4f8362c747">disable_registration_event_cleanup</a> ()</td></tr>
<tr class="memdesc:aeed67b035bb486ec604fdc4f8362c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable cleanup of registration events (see enable_registration_event_cleanup). <br /></td></tr>
<tr class="separator:aeed67b035bb486ec604fdc4f8362c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7ef0d5cef1d3318bfd315e73d7834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff7ef0d5cef1d3318bfd315e73d7834"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a6ff7ef0d5cef1d3318bfd315e73d7834">is_registration_event_cleanup_enabled</a> ()</td></tr>
<tr class="memdesc:a6ff7ef0d5cef1d3318bfd315e73d7834"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether registration cleanup is enabled <br /></td></tr>
<tr class="separator:a6ff7ef0d5cef1d3318bfd315e73d7834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">object registration</div></td></tr>
<tr class="memitem:ad3783da9c295a7c532f2ea35d2a06abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ad3783da9c295a7c532f2ea35d2a06abb">register_object</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> object, const std::string &amp;options)</td></tr>
<tr class="memdesc:ad3783da9c295a7c532f2ea35d2a06abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an object and send event to all current registration ref_listeners()  <a href="#ad3783da9c295a7c532f2ea35d2a06abb">More...</a><br /></td></tr>
<tr class="separator:ad3783da9c295a7c532f2ea35d2a06abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cfc52fcd0ab300675162f464038e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aa6cfc52fcd0ab300675162f464038e45">unregister_object</a> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> object, const std::string &amp;options)</td></tr>
<tr class="memdesc:aa6cfc52fcd0ab300675162f464038e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">unregister an object and send event to all current registration ref_listeners()  <a href="#aa6cfc52fcd0ab300675162f464038e45">More...</a><br /></td></tr>
<tr class="separator:aa6cfc52fcd0ab300675162f464038e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">configuration and gui files</div></td></tr>
<tr class="memitem:a6f26c596a7d1653508dcf0f1739040da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f26c596a7d1653508dcf0f1739040da"></a>
<a class="el" href="a00705.html#a41ed99892cc76b1f339b9a0693bb0e1f">named_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a6f26c596a7d1653508dcf0f1739040da">find_object_by_name</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6f26c596a7d1653508dcf0f1739040da"><td class="mdescLeft">&#160;</td><td class="mdescRight">in case permanent registration is active, look for a registered object by name <br /></td></tr>
<tr class="separator:a6f26c596a7d1653508dcf0f1739040da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9a67761bb0d9e72dfb91924fded64f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add9a67761bb0d9e72dfb91924fded64f"></a>
<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#add9a67761bb0d9e72dfb91924fded64f">find_object_by_type</a> (const std::string &amp;type_name)</td></tr>
<tr class="memdesc:add9a67761bb0d9e72dfb91924fded64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">in case permanent registration is active, look for a registered object by type name <br /></td></tr>
<tr class="separator:add9a67761bb0d9e72dfb91924fded64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a10347f7bb1ff69bcf6a43cd7d2e891"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a10347f7bb1ff69bcf6a43cd7d2e891"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a8a10347f7bb1ff69bcf6a43cd7d2e891">register_config_file_driver</a> (<a class="el" href="a00023.html">config_file_driver</a> *cfd)</td></tr>
<tr class="memdesc:a8a10347f7bb1ff69bcf6a43cd7d2e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to register a <a class="el" href="a00023.html" title="abstract interface for a config file driver that handles permanent registration and gui config files...">config_file_driver</a> <br /></td></tr>
<tr class="separator:a8a10347f7bb1ff69bcf6a43cd7d2e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2406c2621b5dfd2f92d3384e9b14189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2406c2621b5dfd2f92d3384e9b14189"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#af2406c2621b5dfd2f92d3384e9b14189">process_config_file</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:af2406c2621b5dfd2f92d3384e9b14189"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpret a config file <br /></td></tr>
<tr class="separator:af2406c2621b5dfd2f92d3384e9b14189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fa99b284a53727252312a9814a263a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6fa99b284a53727252312a9814a263a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#ac6fa99b284a53727252312a9814a263a">process_gui_file</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:ac6fa99b284a53727252312a9814a263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpret a gui file <br /></td></tr>
<tr class="separator:ac6fa99b284a53727252312a9814a263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">support for driver, listener and factory registration</div></td></tr>
<tr class="memitem:ad6955e267d77503183deb29807c66220"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6955e267d77503183deb29807c66220"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>guess_created_type_name</b> (const char *item_text)</td></tr>
<tr class="separator:ad6955e267d77503183deb29807c66220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712a9a905b92e4f0377a0033fc9707f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a712a9a905b92e4f0377a0033fc9707f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>register_factory_object</b> (<a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> fo, const char *item_text, char shortcut)</td></tr>
<tr class="separator:a712a9a905b92e4f0377a0033fc9707f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">processing of commands</div></td></tr>
<tr class="memitem:aa66b1e03845e1311a99a38fd276e7233"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66b1e03845e1311a99a38fd276e7233"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#aa66b1e03845e1311a99a38fd276e7233">show_all</a> ()</td></tr>
<tr class="memdesc:aa66b1e03845e1311a99a38fd276e7233"><td class="mdescLeft">&#160;</td><td class="mdescRight">show information about all registered members <br /></td></tr>
<tr class="separator:aa66b1e03845e1311a99a38fd276e7233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0e3861c731016fa00726b7e17eadd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00705.html#a5e0e3861c731016fa00726b7e17eadd1">process_command</a> (const std::string &amp;cmd, bool eliminate_quotes=true)</td></tr>
<tr class="memdesc:a5e0e3861c731016fa00726b7e17eadd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">process a command given as string.  <a href="#a5e0e3861c731016fa00726b7e17eadd1">More...</a><br /></td></tr>
<tr class="separator:a5e0e3861c731016fa00726b7e17eadd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>the base namespace holds the base hierarchy, support for plugin registration and signals </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a746925f26d076c26742b2dc558cbae36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00705.html#a746925f26d076c26742b2dc558cbae36">cgv::base::TraversePolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>different traversal policies </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a746925f26d076c26742b2dc558cbae36a4dd87fc30d8a2e369fe315eb9ccde557"></a>TP_ONLY_FOCUS&#160;</td><td class="fielddoc">
<p>traverse all children </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a746925f26d076c26742b2dc558cbae36a69ee76315433dc44f8bfa441afefa249"></a>TP_FIRST_FOCUS&#160;</td><td class="fielddoc">
<p>traverse only the focused child </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a746925f26d076c26742b2dc558cbae36a169ba2fab3a13ea551eb8d8800e459bb"></a>TP_AUTO_FOCUS&#160;</td><td class="fielddoc">
<p>first traverse focused and then the remaining children </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a746925f26d076c26742b2dc558cbae36a7b2b5c718b50e4241491dcb951599a8b"></a>TP_STOP_ON_SUCCESS&#160;</td><td class="fielddoc">
<p>like previous but change focus to the child, where traversal succeeded </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a746925f26d076c26742b2dc558cbae36a33806b12ea827401e0a110036ddbeabe"></a>TP_STOP_ON_FAILURE&#160;</td><td class="fielddoc">
<p>this is an optional flag for traversals with methods that return a bool. If the returned bool is true, traversal stops if this flag is set </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac56137cd8bf24c23f7f6ef15a417bbdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API bool cgv::base::attach </td>
          <td>(</td>
          <td class="paramtype">base_ptr&#160;</td>
          <td class="paramname"><em>slot_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">base_ptr&#160;</td>
          <td class="paramname"><em>attachment_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to attach an object to an object of type <a class="el" href="a00018.html">attach_slot</a>. </p>
<p>Return whether the slot_object implements the <a class="el" href="a00018.html">attach_slot</a> interface and could retreive the attachment. </p>

</div>
</div>
<a class="anchor" id="ada908977e738c6da6230a698912bebc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::define_registration_order </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>partial_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>before_contructor_execution</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>when</em> = <code>&quot;always&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specify a partial order of objects for registration </p>
<p><code>partial_order</code> is a semicolon separated list of type names that can ignore name spaces. <code>before_contructor_execution</code> tells whether the reordering should happen before constructors of delayed registration events are called. <code>when</code> specifies in which call to <code>enable_registration</code> the reordering should happen. Possible values are</p><ul>
<li>"always"</li>
<li>"program" only once for the enable event of the executed program</li>
<li>"plugins" for enable events of all loaded plugins</li>
<li>&lt;plugin_name&gt; only for the enable event of the plugin with the given name If several partial orders are defined for an enable call, a combined partial order is computed and used to find the order closest to the actual registration order that is in accordance to the combined partial order. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa839bf46a9e8abb32cfea4964ec91507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::enable_registration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable registration and send all registration events that where emitted during disabled registration </p>
<p>Enable registration (default is that registration is disabled).</p>
<p>If registration has been disabled before, send all registration events that where emitted during disabled registration. </p>

</div>
</div>
<a class="anchor" id="a5972c6c1a1833e46393f9361ea2b860a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::enable_registration_event_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable cleanup of registration events (default). </p>
<p>If registration event cleanup is disabled, registration events are not discarded as soon as objects have been registered. This makes objects available to listeners that are registered later. </p>

</div>
</div>
<a class="anchor" id="a87c767fdeab1d282ea353800d967ca44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API std::string cgv::base::find_data_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_directory</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>master_path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a file with the given strategy and return the file name extended by the necessary path. The strategy defines in which search paths the file should be looked for, whether the search paths should be searched recursively and in which order the search paths should be searched (see details below). Optional arguments are a sub_directory and a master_path. For all non recursive searches the sub_directory will be added to each search path and the file is first looked up in the sub_directory. The master_path just defines another search path that can be used by the search strategy.</p>
<p>The search strategy is a string containing one letter for each search command, which are processed in the order of the string. Each capital letter causes a recursive search. The following search commands are available:</p><ul>
<li>r/R ... search resource files (no recursive search necessary as resource files do not have paths) and if found add the prefix "res://" to the file_name</li>
<li>c/C ... search current directory (here no path prefix is used)</li>
<li>m/M ... search master path</li>
<li>d/D ... search all data paths registered in the environment variable CGV_DATA</li>
<li>p/P ... search the path of the parent on the parent path stack that is controlled with <a class="el" href="a00705.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths...">push_file_parent()</a> and <a class="el" href="a00705.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack. ">pop_file_parent()</a></li>
<li>a/A ... search all anchester paths of the all parents on the parent path stack that is controlled with <a class="el" href="a00705.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths...">push_file_parent()</a> and <a class="el" href="a00705.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack. ">pop_file_parent()</a> As an example the strategy "cpmD" first looks in the current directory, then in the parent directory, then in the master path and finally recursively in each of the registered data paths. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1e3f23268db7fec467dfd98ab36094f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API <a class="el" href="a00705.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> cgv::base::get_attachment </td>
          <td>(</td>
          <td class="paramtype">base_ptr&#160;</td>
          <td class="paramname"><em>slot_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query the attachment of an <a class="el" href="a00018.html">attach_slot</a> object. </p>
<p>If the slot_object is not derived from the <a class="el" href="a00018.html">attach_slot</a> interface, return an empty base_ptr. </p>

</div>
</div>
<a class="anchor" id="aec69e775624f1ca64e001ff8b1254344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void * cgv::base::get_attachment_data </td>
          <td>(</td>
          <td class="paramtype">base_ptr&#160;</td>
          <td class="paramname"><em>slot_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query the user data of the attachment of an <a class="el" href="a00018.html">attach_slot</a> object. </p>
<p>If the slot_object is not derived from the <a class="el" href="a00018.html">attach_slot</a> interface, return the null pointer. </p>

</div>
</div>
<a class="anchor" id="ac63edc5ab309dd943500adb7801deeb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::has_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_error</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simple parsing support to access values of properties in a string of property assignment </p>
<p>Given an option string (first parameter) with name-value-pairs, i.e. "x=10.4;tooltip='help'" and a property name (second parameter), the function returns whether the option string contains an assignment of the queried property and if yes, the value is stored in the reference given in the third parameter. The type casts supported by the <a class="el" href="a00315.html">cgv::type::variant</a> type are used when converting to the reference type.</p>
<p>Examples:</p>
<p>true == has_property("x=10.4;tooltip='help'", "x", dbl_var)"       ==&gt; dbl_var = 10.4
    true  == has_property("x=10.4;tooltip='help'", "x", str_var)" ==&gt; str_var = "10.4" true == has_property("x=10.4;tooltip='help'", "tooltip", str_var)" ==&gt; str_var = "help"
    false == has_property("x=10.4;tooltip='help'", "y", int_var)" ==&gt; int_var ... not changed </p>

</div>
</div>
<a class="anchor" id="acf58539e451af7248fa0d2e64bbb48f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void * cgv::base::load_plugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a plugin or dll and return a handle to the plugin, or 0 if loading was not successful. </p>
<p>During plugin loading the registration is always disabled in order to avoid deadlocks that can arise when a registered object triggers loading of another dll. </p>

</div>
</div>
<a class="anchor" id="a5e0e3861c731016fa00726b7e17eadd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CGV_API cgv::base::process_command </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eliminate_quotes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>process a command given as string. </p>
<p>Return whether the command was processed correctly. If eliminate_quotes is set to true, quotes around the command arguments are eliminated. This feature is used for commands specified on the command line, where spaces in the command arguments would split one command into pieces. Quotes are used then to protect the command from splitting.</p>
<p>The following commands are supported:</p><ul>
<li>show all ... print out information on all registered objects</li>
<li>plugin:file_name ... read a plugin</li>
<li>config:file_name ... read a config file</li>
<li>gui:file_name ... read a gui description file</li>
<li>name(xxx):assignment list ... find registered object by name xxx and process assignments on them</li>
<li>type(yyy):assignment list ... find registered object by type yyy and process assignments on them</li>
</ul>
<p>The assigment list in the name and type commands are of the form:</p>
<p>member_name_1=value_1;member_name_2=value_2;... </p>

</div>
</div>
<a class="anchor" id="aa3f550111b3915df062b0bbda4795f37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API std::vector&lt; std::string &gt; &amp; cgv::base::ref_parent_file_stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a reference to the data path list, which is constructed from the environment variable CGV_DATA </p>
<p>return a reference to the parent file stack controlled with <a class="el" href="a00705.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths...">push_file_parent()</a> and <a class="el" href="a00705.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack. ">pop_file_parent()</a>, where the last vector element is the latestly pushed one </p>

</div>
</div>
<a class="anchor" id="ad3783da9c295a7c532f2ea35d2a06abb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::register_object </td>
          <td>(</td>
          <td class="paramtype">base_ptr&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register an object and send event to all current registration ref_listeners() </p>
<p>register an object.</p>
<p>This will send an event to all currently registered registration listeners. The options parameter can be used to select a specific listener. </p>

</div>
</div>
<a class="anchor" id="a9e4204680cce6ce77447fcab18a7fab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void cgv::base::register_prog_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prog_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the file name of the current program. </p>
<p>simply pass argv[0] in the main procedure. This is done automatically in the process_command_line_args function. </p>

</div>
</div>
<a class="anchor" id="aa6cfc52fcd0ab300675162f464038e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::unregister_object </td>
          <td>(</td>
          <td class="paramtype">base_ptr&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unregister an object and send event to all current registration ref_listeners() </p>
<p>unregister an object and send event to all currently registered registration listeners </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00704.html">cgv</a></li><li class="navelem"><a class="el" href="a00705.html">base</a></li>
    <li class="footer">Generated on Mon Jun 26 2017 12:41:45 for cgv by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
